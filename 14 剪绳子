剪绳子1
贪心算法：
第一优先级： 3；把数字 nn 拆成尽可能多的 3 之和；
特殊情况： 拆完后，如果余数是 1；则应把最后的3+1 替换为 2+2，因为后者乘积更大；
第二优先级： 2；留下的余数如果是 2，则保留，不再拆为 1+1。

复杂度分析：
时间复杂度 O(1)O(1) ： 仅有求整、求余、次方运算。
求整和求余运算：查阅资料，提到不超过机器数的整数可以看作是 O(1)；
次方运算：查阅资料，提到不超过机器数的整数可以看作是 O(1)。
空间复杂度 O(1)O(1) ： a 和 b 使用常数大小额外空间。

class Solution {
public:
    int cuttingRope(int n) {
        if (n < 4)return n - 1;
        int a = n / 3, b = n % 3;
        if (b == 0)return a = pow(3, a);
        if (b == 1)return a = pow(3, a-1) * 4;
        if (b == 2)return a = pow(3, a) * 2;
        return a;
    }
};

//动态规划
考虑最后一步的情况，即最后剪的一下，会把绳子分为两部分，且两部分的结果互不影响

定义 dp[i] 表示长度i的绳子能得到的最大乘积
则 dp[i] 等于 在绳子区间[0, i)之间剪开的两部分乘积最大值
如果剪开位置为k，则区间分为[0, k)和[k, i)两部分
第一部分长度为k, 第二部分长度为i-k
第二部分存在剪和不剪两种情况，剪的时候值为dp[i-k]，不剪的时候取（i-k)
于是得到状态转换方程：

dp[i] = max{ k * dp[i-k], k * (i-k)} (2<=k<=i)

class Solution{
public:
    int cuttingRope(int n)
    {
        vector<int> dp(n+1,0);
        dp[1]=1;
        dp[2]=1;
        for(int i=3;i<=n;i++)
        {
            for(int k=2;k<=i-1;k++)
            {
                dp[i]=max(dp[i],max(k*(i-k),k*dp[i-k]));
            }
        }
        return dp[n];
    }
};

剪绳子2  存在大数问题
贪心
我们首先考虑对于一段长n的绳子，我们可以切出的结果包含什么？
1会包含吗？ 不会，因为1 * (k - 1) < k, 只要把1和任何一个其他的片段组合在一起就有个更大的值
2可以
3可以
4可以吗？ 它拆成两个2的效果和本身一样，因此也不考虑
5以上可以吗？ 不可以，这些绳子必须拆，因为总有一种拆法比不拆更优，比如拆成 k / 2 和 k - k / 2
综上, 最后的结果只包含2和3(当然当总长度为2和3时单独处理), 那么很显然n >= 5时， 3*(n - 3) >= 2 * (n - 2) ，因此我们优先拆成3，最后剩余的拆成2。最后的结果一定是由若干个3和1或2个2组成.

class Solution {
public:
    //n >= 5 2*(n-2) > n   3*(n-3) > n  且3*(n-3) >= 2*(n-2)
    //n = 4 2 * 2 > 1 * 3
    //2和3不能再分了  分了就变小了 且3优于2
    int cuttingRope(int n) {
        if(n <= 3) return n-1;
        long rs = 1;
        while (n > 4) {
            //3最优
            rs *= 3;//分成多个三
            rs %= 1000000007;
            n -= 3;
        }
        //n = 4,5,6,7,8,9,10
        //n = 4,2,3,4,2,3,4
        //只可能2 3 4，2，3不能再分了
        //4 可以分成1 * 3  2 * 2,所以还是4最优
        return (rs * n) % 1000000007;
    }
};

dp思想我就不说了，具体到这个题我们发现4可以拆成22，5可以拆成23,也就是说后面的数都可以用2或者3表示且比原数大，
  计算发现尽可能多的3才会带来最大值。那么递归过程就很好写了。但是还有个问题因为必须保证最少两段，
  所以前期分出来了一部分副作用的1，直到6才能完成最佳的取值，所以初始化工作较长。通常分配dp的空间为n，
  但是本题初始化较长，可能已经超过了N，所以直接分配1001的空间。不过问题不大，没什么影响。

class Solution {
public:
    int cuttingRope(int n) {
        vector<long> dp(1001,0);
        dp[1]=1;
        dp[2]=1;
        dp[3]=2;
        dp[4]=4;
        dp[5]=6;
        dp[6]=9;
        for(int i=7;i<=n;i++){
            dp[i]=(dp[i-3]*3)%1000000007;
        }
        return dp[n];
    }
};
