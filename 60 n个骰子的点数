动态规划
使用动态规划解决问题一般分为三步：
    表示状态
    找出状态转移方程
    边界处理

下面我们一步一步分析，相信你一定会有所收获！

表示状态
    分析问题的状态时，不要分析整体，只分析最后一个阶段即可！因为动态规划问题都是划分为多个阶段的，
    各个阶段的状态表示都是一样，而我们的最终答案在就是在最后一个阶段。

对于这道题，最后一个阶段是什么呢？

通过题目我们知道一共投掷 n 枚骰子，那最后一个阶段很显然就是：当投掷完 n 枚骰子后，各个点数出现的次数。
注意，这里的点数指的是前 n 枚骰子的点数和，而不是第 n 枚骰子的点数，下文同理。
找出了最后一个阶段，那状态表示就简单了。

首先用数组的第一维来表示阶段，也就是投掷完了几枚骰子。
然后用第二维来表示投掷完这些骰子后，可能出现的点数。
数组的值就表示，该阶段各个点数出现的次数。
所以状态表示就是这样的：dp[i][j] ，表示投掷完 i 枚骰子后，点数 j 的出现次数。

找出状态转移方程
找状态转移方程也就是找各个阶段之间的转化关系，同样我们还是只需分析最后一个阶段，分析它的状态是如何得到的。

最后一个阶段也就是投掷完 n 枚骰子后的这个阶段，我们用 dp[n][j]来表示最后一个阶段点数 j 出现的次数。

单单看第 n 枚骰子，它的点数可能为 1 , 2, 3, ... , 6 ，因此投掷完 n 枚骰子后点数 j 出现的次数，
可以由投掷完 n-1 枚骰子后，对应点数 j-1, j-2, j-3, ... , j-6 出现的次数之和转化过来。

for (第n枚骰子的点数 i = 1; i <= 6; i ++) {
    dp[n][j] += dp[n-1][j - i]
}
n表示阶段，j 表示投掷完 n 枚骰子后的点数和，i 表示第 n 枚骰子会出现的六个点数。

边界处理
这里的边界处理很简单，只要我们把可以直接知道的状态初始化就好了。
我们可以直接知道的状态是啥，就是第一阶段的状态：投掷完 11 枚骰子后，它的可能点数分别为 1, 2, 3, ... , 66 ，并且每个点数出现的次数都是 1 .
for (int i = 1; i <= 6; i ++) {
    dp[1][i] = 1;
}
class Solution {
public:
    vector<double> twoSum(int n) {
        int dp[15][70];
        memset(dp, 0, sizeof(dp));
        for (int i = 1; i <= 6; i ++) {
            dp[1][i] = 1;
        }
        for (int i = 2; i <= n; i ++) {
            for (int j = i; j <= 6*i; j ++) {
                for (int cur = 1; cur <= 6; cur ++) {
                    if (j - cur <= 0) {
                        break;
                    }
                    dp[i][j] += dp[i-1][j-cur];
                }
            }
        }
        int all = pow(6, n);
        vector<double> ret;
        for (int i = n; i <= 6 * n; i ++) {
            ret.push_back(dp[n][i] * 1.0 / all);
        }
        return ret;
    }
}; 
空间优化
我们知道，每个阶段的状态都只和它前一阶段的状态有关，因此我们不需要用额外的一维来保存所有阶段。

用一维数组来保存一个阶段的状态，然后对下一个阶段可能出现的点数 jj 从大到小遍历，实现一个阶段到下一阶段的转换。

class Solution {
public:
    vector<double> twoSum(int n) {
        int dp[70];
        memset(dp, 0, sizeof(dp));
        //初始化
        for (int i = 1; i <= 6; i ++) {
            dp[i] = 1;
        }
        for (int i = 2; i <= n; i ++) {//n个骰子
            for (int j = 6*i; j >= i; j --) {//n个骰子掷出去以后，所有点数出现的和的可能，例如两个骰子，出现的点数和j为2，3，4，5，6，7，8，9，10，11，12
                dp[j] = 0;//从后往前记录各个点数的出现的次数，12，11，10，9，。。。2.所以前一状态需要置0
                for (int cur = 1; cur <= 6; cur ++) {//第n个骰子出现的点数
                    if (j - cur < i-1) {//此句的含义：i表示阶段，也就是扔了几个骰子；j表示 i 这个阶段可能出现的总点数，cur 是第 i 颗骰子的点数，
                                        //所以 j = cur + 前 i - 1 个骰子可能出现的点数；因为前 i-1颗骰子可能出现的最小点数为 i - 1 ，
                                        //也就是每颗骰子的点数都为 1。所以j - cur < i - 1 的所有情况是不合理的，也就是不可能出现的，因此就无需继续判断。
                        break;
                    }
                    dp[j] += dp[j-cur];
                }
            }
        }
        int all = pow(6, n);
        vector<double> ret;
        for (int i = n; i <= 6 * n; i ++) {
            ret.push_back(dp[i] * 1.0 / all);
        }
        return ret;
    }
};

