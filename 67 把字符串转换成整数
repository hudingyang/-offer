根据题意，有以下四种字符需要考虑：

首部空格： 删除之即可；
符号位： 三种情况，即 '+' , '−' , ''无符号" ；新建一个变量保存符号位，返回前判断正负即可。
非数字字符： 遇到首个非数字的字符时，应立即返回。
数字字符：
字符转数字： “此数字的 ASCII 码” 与 “ 0 的 ASCII 码” 相减即可；
数字拼接： 若从左向右遍历数字，设当前位字符为 c ，当前位数字为 x ，数字结果为 res ，则数字拼接公式为：
res=10×res+x
x=ascii(c)−ascii(′0′)

题目要求返回的数值范围应在 [-2^{31}, 2^{31} - 1]，因此需要考虑数字越界问题。

数字越界处理： 在每轮数字拼接后，判断数字结果 resres 是否超过 2^{31} - 1，若超过则加上符号位直接返回。

复杂度分析：
时间复杂度 O(N) ： 其中 N 为字符串长度，线性遍历字符串占用 O(N) 时间。
空间复杂度 O(N) ： 删除首尾空格后需建立新字符串，最差情况下占用 O(N) 额外空间。


class Solution {
public:
    int strToInt(string str) {
        int k=0;
        while(str[k]==' ') ++k;//找到第一个非空格字符
        int res = 0, flag = 1;//res记录结果的值，flag记录符号位
        if(str[k]=='-') flag=-1;//如果第一个字符是-号，则符号位为-1
        if(str[k]=='-' || str[k]=='+') ++k;//如果第一个字符是符号位，则从下一个字符开始遍历寻找最长数字串
        while(k<str.size() && isdigit(str[k]))//当k未到达字符串末尾并且当前字符是数字时
        {
            int r = str[k] - '0';//记录当前数字
            if(res>INT_MAX/10 || (INT_MAX/10==res && r>7))//判断当前结果是否溢出,溢出直接返回最大值或者最小值
                return flag==1?INT_MAX:INT_MIN;
            res =res*10+r;//累加当前数字，末尾多一位数字等价将原来数字*10再加上所加的数字即可
            ++k;
        }
        return res*flag;
    }
};
