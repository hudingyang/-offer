动态规划解题一般分为三步：

1、表示状态
    每一种状态都是使用数组的维数来表示的。
    一般我们会先使用数组的第一维来表示阶段，然后再根据需要通过增加数组维数，来添加其它状态。

2、找出状态转移方程
    状态转移指的是，当前阶段的状态如何通过之前计算过的阶段状态得到。

3、初始化边界
    初始化边角状态，以及第一个阶段的状态。
    
例题分析：
53、最大子序和
给定一个整数数组nums，找到一个具有最大和的连续子数组（子数组最少包含一个元素），并返回其最大和。

输入: [-2,1,-3,4,-1,2,1,-5,4],
输出: 6
解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。

思路分析
首先是对这个问题进行阶段划分。我们可以把这个长度为n的数组划分为n个阶段，例如第n个阶段代表前n个元素的最大子序和，我们用f(n)来表示 。

使用数组的第一维来表示阶段：

 f(n)表示第n个阶段，也就是前n个元素的最大子序和。

f(n-1)表示第n-1个阶段，也就是前n-1个元素的最大子序和。

......

仅仅表示了阶段f(n)，我们还是很难看出f(n)和f(n-1)之间的转移关系。因此我们需要再寻找对转移策略有影响的其它状态，
我们发现f(n)到 f(n-1)的转移策略与它们的结尾元素是否被选择有关，因此再添加一维来表示对应阶段结尾元素的选取状态。
具体情况请往下看。

1、状态表示
 f(n)(0)表示前n个元素中，不选择第n个元素时的最大子序和
 f(n)(1)表示前n个元素中，选择第n个元素时的最大子序和

2、状态转移
      f(n)(0)=max{f(n-1)(0),f(n-1)(1)}
      f(n)(1)=max{f(n-1)(1)+num[n],num[n]}

3、边界处理
    f(0)(0)=INT_MIN
    f(0)(1)=num[0];
代码：
int maxSubArray(vector<int>& nums) {
    int dp[100010][2];
    int len=nums.size();
    dp[0][0]=INT_MIN;
    dp[0][1]=nums[0];
    
    for(int i=1;i<len;i++)
    {
        dp[i][0]=max(dp[i-1][0],dp[i-1][1]);
        dp[i][0]=max(dp[i-1][1]+nums[i],nums[i]);
    }
    return max(dp[len-1][0],dp[len-1][1]);
}
另一种思路
在这我们换一种状态表示的方法，帮助大家开阔思路。我们通过动态规划的方式，
计算出以每个元素作为结尾的最大子序和，然后在这些结果中选取最大的一个，作为最终的结果。

1、状态表示
 f(n)表示以第n个元素作为结尾时的最大子序和
2、状态转移
  f(n)=max(f(n-1)+nums[i],nums[i])
3、边界处理
  f(0)=nums[0];
代码：
int maxSubArray(vector<int>& nums) {
    int dp[100010];
    dp[0] = nums[0];
    for (int i = 1; i < nums.size(); i ++) {
        dp[i] = max(nums[i], nums[i] + dp[i-1]);
    }
    int ret = INT_MIN;
    for (int i = 0; i < nums.size(); i ++) {
        ret = max(ret, dp[i]);
    }
    return ret;
}


//32 最长有效括号
//动态规划思路：
    1、确定状态：
        研究最优策略的最后一步
        化为子问题
    2、转移方程：
        根据子问题定义可得
    3、初始条件和边界条件
    4、计算顺序
    
定义dp数组表示其中第i个元素表示一下标为i的字符串的最长有效字符串的长度

确定状态：
class Solution {
public:
    int longestValidParentheses(string s) {
        int size = s.length();
        vector<int> dp(size, 0);

        int maxVal = 0;
        for(int i = 1; i < size; i++) {
            if (s[i] == ')') {
                if (s[i - 1] == '(') {
                    dp[i] = 2;
                    if (i - 2 >= 0) {
                        dp[i] = dp[i] + dp[i - 2];
                    }
                } else if (dp[i - 1] > 0) {
                    if ((i - dp[i - 1] - 1) >= 0 && s[i - dp[i - 1] - 1] == '(') {
                        dp[i] = dp[i - 1] + 2;
                        if ((i - dp[i - 1] - 2) >= 0) {
                            dp[i] = dp[i] + dp[i - dp[i - 1] - 2];
                        }
                    }
                }
            }
            maxVal = max(maxVal, dp[i]);
        }
        return maxVal;
    }
};
