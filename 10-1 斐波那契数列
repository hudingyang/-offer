解题思路：
斐波那契数列的定义是 f(n + 1) = f(n) + f(n - 1) ，生成第 n 项的做法有以下几种：

递归法：
原理： 把 f(n)问题的计算拆分成 f(n-1)和 f(n-2)两个子问题的计算，并递归，以 f(0) 和 f(1) 为终止条件。
缺点： 大量重复的递归计算，例如 f(n) 和 f(n - 1)两者向下递归需要 各自计算 f(n−2) 的值。
记忆化递归法：
原理： 在递归法的基础上，新建一个长度为 nn 的数组，用于在递归时存储 f(0) 至 f(n) 的数字值，重复遇到某数字则直接从数组取用，避免了重复的递归计算。
缺点： 记忆化存储需要使用 O(N)的额外空间。
动态规划：
原理： 以斐波那契数列性质f(n+1)=f(n)+f(n−1) 为转移方程。
从计算效率、空间复杂度上看，动态规划是本题的最佳解法。

class solution
{
public:
  int fib(int n)
  {
      int dp[101];
      dp[0]=0;
      dp[1]=1;
      for(int i=2;i<=n;i++)
        dp[i]=(dp[i-1]+dp[i-2])%1000000007;
      return dp[n];
  }
};


//青蛙跳台
解题思路
1.n==0时，返回的步数时1？（因为题目就是这么规定的，如果要理解： 0 层台阶也有一种跳法（即不跳））
2.递归三步走：
a.定义函数。
b.找到出口，n==0时，返回的步数时1；n==1时，返回1；
c.找到等价交换式。f(n)=f(n-1)+f(n-2);
3.使用递归函数，等台阶到43时，就会报出时间超时。
4.进行优化，因为递归时会存在重复计算的场景，申请一个固定长度的数组，用于保存过程数据。
class Solution {
public:
    int numWays(int n) {
        int a=1,b=1,sum;
        for(int i=0;i<n;i++)
        {
            sum=(a+b)%1000000007;
            a=b;
            b=sum;
        }
        return a;
    }
};
